<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Masyvų iteraciniai metodai IR destruktūrizavimas IR sąlygos(advanced)</title>
  <script src="./scripts/main.js" defer></script>
</head>
<body>
    <main>
      <section id="forEach">
        <h1>ForEach</h1>
        <h3>Syntax:</h3>
        <p>
          forEach( (element) => { veiksmai... } )
          forEach( (element, i) => { veiksmai... } )
          forEach( (element, i, array) => { veiksmai... } )
        </p>
        <p>
          ForEach metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu atlieka kažkokius veiksmus su tos iteracijos masyvo elementu (masyvas[i] elementu).
          ForEach'as negali grąžinti reikšmės (neturi return).
        </p>
      </section>
      <section id="filter">
        <h1>Filter</h1>
        <h3>Syntax:</h3>
        <p>
          filter( (element) => { veiksmai... } )
          filter( (element, i) => { veiksmai... } )
          filter( (element, i, array) => { veiksmai... } )
        </p>
        <p>
          Filter metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu tikrina ar iteracijos masyvo elementas (masyvas[i] elementas) tenkina sąlygą. Jeigu elementas sąlygą tenkina - elementas yra grąžinamas, jeigu ne - negrąžinamas.
        </p>
      </section>
      <section id="map">
        <h1>Map</h1>
        <h3>Syntax:</h3>
        <p>
          map( (element) => { veiksmai... } )
          map( (element, i) => { veiksmai... } )
          map( (element, i, array) => { veiksmai... } )
        </p>
        <p>
          Map metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu kažkaip mutuoja kiekvieną iteracijos masyvo elementą (masyvas[i] elementą) ir jį grąžina.
        </p>
      </section>
      <section id="reduce">
        <h1>Reduce</h1>
        <h3>Syntax:</h3>
        <p>
          reduce( (accumulator, currentValue) => { veiksmai... } )
          reduce( (accumulator, currentValue, i) => { veiksmai... } )
          reduce( (accumulator, currentValue, i, array) => { veiksmai... } )
          
          reduce( (accumulator, currentValue) => { veiksmai... }, initialValue )
          reduce( (accumulator, currentValue, i) => { veiksmai... }, initialValue )
          reduce( (accumulator, currentValue, i, array) => { veiksmai... }, initialValue )
        </p>
        <p>
          Reduce metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu su akumuliatoriaus (reikšmė, kurią grąžino praeitas ciklas) (accumulator) atlieka kažkokį veiksmą, naudodamas šios iteracijos masyvo elementą (masyvas[i] elementą) (currentValue). Metodo gale, grąžina vieną reikšmę (visų masyvo elementų rezultatą).
          Jeigu yra nurodyta pradinė reikšmė (initialValue), tuomet pirmosios iteracijos metu yra atliekami veiksmai su pradine reikšme (initialValue) ir pirmuoju masyvo elementu.
          Jeigu nėra nurodyta pradinė reikšmė (initialValue), tuomet pirmosios iteracijos metu yra atliekami veiksmai su pirmąja masyvo reikšme ir antrąja masyvo reikšme.
        </p>
      </section>
      <section id="reduceRight">
        <h1>ReduceRight</h1>
        <p>
          Lygiai tas pats kas ir reduce, tik kad iš kito galo (right-to-left(rtl)). 
        </p>
      </section>
      <section id="flatMap">
        <h1>FlatMap</h1>
        <p>
          Apjungtas flat(1) ir map metodai į vieną. Neturi galimybės keisti flat'o gylio.
        </p>
      </section>
      <section id="some">
        <h1>Some</h1>
        <p>
          Some metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu tikrina ar bent vienas iteracijos masyvo elementas atitinka nurodytą sąlygą. 
          Jeigu bent vienas elementas atitinka nurodytą sąlygą - metodas grąžina - true.
          Jeigu nei vienas elementas neatitinka nurodytos sąlygos - metodas grąžina - false;
        </p>
      </section>
      <section id="every">
        <h1>Every</h1>
        <p>
          Every metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu tikrina ar kiekvienas iteracijos masyvo elementas atitinka nurodytą sąlygą.
          Jeigu kiekvienas elementas atitinka nurodytą sąlygą - metodas grąžina - true.
          Jei bent vienas elementas neatitinka nurodytos sąlygos - metodas grąžina - false.
        </p>
      </section>
      <section id="find">
        <h1>Find</h1>
        <p>
          Find metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu tikrina ar iteracijos masyvo elementas atitinka nurodytą sąlygą.
          Jeigu iteracijos masyvo elementas atitinka nurodytą sąlygą - grąžina elementą.
          Jeigu iteracijos masyvo elementas neatitinka nurodytos sąlygos - juda prie sekančios iteracijos.
          Jeigu po viso masyvo iteracijų nėra randamas elementas atitinkantis nurodytos sąlygos - grąžina undefined.
        </p>
      </section>
      <section id="findLast">
        <h1>Find Last</h1>
        <p>
          Atlieka tą patį ką ir find metodas, tik nuo kito galo. (right-to-left (rtl))
        </p>
      </section>
      <section id="findIndex">
        <h1>Find Index</h1>
        <p>
          FindIndex metodas - suka ciklą per visą masyvą ir kiekvienos iteracijos metu tikrina ar iteracijos masyvo elementas atitinka nurodytą sąlygą.
          Jeigu iteracijos masyvo elementas atitinka nurodytą sąlygą - grąžina elemento indeksą.
          Jeigu iteracijos masyvo elementas neatitinka nurodytos sąlygos - juda prie sekančios iteracijos.
          Jeigu po viso masyvo iteracijų nėra randamas elementas atitinkantis nurodytos sąlygos - grąžina -1.
        </p>
      </section>
      <section id="findLastIndex">
        <h1>Find Last Index</h1>
        <p>
          Atlieka tą patį ką ir findIndex metodas, tik nuo kito galo. (right-to-left (rtl))
        </p>
      </section>

      <section id="imantriuSalygu">
        <h1>Ternary ( ?: )</h1>
        <p>
          Sąlygos užrašymo būdas, kur sąlyga rašoma be jokio if'o, o už jos rašomas '?' ženklas, po kurio aprašomas 'true' atvejis, po kurio rašomas ':', po kurio rašomas else atvejis. Else atvejis gali būti papildoma sąlyga, už kurios vėl atkartojama ternary seka.
        </p>

        <h1>Logical AND (&&)</h1>
        <p>
          Sąlygos užrašymo būdas, kur sąlyga rašoma be jokio if'o, o už jos rašomas '&&' ženklas, po kurio rašomas 'true' atvejis. Šitas būdas neturi else'o ar elseIf'ų.
        </p>
      </section>
      <section id="destrukturizavimas">
        <h1>Destruktūrizavimas</h1>
        <p>
          Elemento/ų reikšmių išskirstymas dalimis.
        </p>
      </section>
    </main>
</body>
</html>